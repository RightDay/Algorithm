# 무식하게 풀기(Brute-Force)

## 1. 도입

사람들이 가장 많이 하는 실수는 쉬운 문제를 어렵게 푸는 것이다. 이런 실수를 피하기 위해 가장 먼저 무식하게 풀 수 있는지 생각해봐야 한다.

**무식하게 풀기(brute-force)는 컴퓨터의 빠른 계산 능력을 이용해 가능한 경우의 수를 일일이 나열하면서 답을 찾는 방법이다.** 이렇게 가능한 방법을 전부 만들어 보는 알고리즘들을 가리켜 **완전 탐색(exhaustive search)**라고 한다.

완전 탐색에 대해 잘 익혀둘 필요가 있다. **완전 탐색은 컴퓨터가 처리하기에는 별 것 아니지만 손으로 직접 풀기에는 경우의 수가 많은 경우에 충분히 빠르면서 가장 구현하기 쉬운 대안**이 된다. 또한 더 빠른 알고리즘의 기반이 되기도 하기 때문에 알아두면 좋다.



## 2. 재귀호출과 완전 탐색

### 재귀 호출(Recursion)

재귀 호출(Recursion), 혹은 **재귀 함수(Recursive Function)는 범위가 작아지면 작아질수록 각 조각들의 형태가 유사해지는 작업에 유용하게 사용되는 개념**이다.

재귀 함수(recursive function)란 자신이 수행할 작업을 유사한 형태의 여러 조각으로 쪼갠 뒤 그 중 한 조각을 수행하고, 나머지를 자기 자신을 호출해 실행하는 함수이다.

모든 재귀 함수는 '더이상 쪼개지지 않는' 최소한의 작업에 도달했을 때 답을 곧장 반환하는 조건문을 포함해야 한다. 이때 **쪼개지지 않는 가장 작은 작업들을 가리켜 재귀 호출의 기저 사례(base case)**라고 한다.

> 1부터 n까지의 합을 계산하는 **반복 함수**

```c
//필수 조건: n>=1
//결과 : 1부터 n까지의 합을 반환한다.
int sum(int n)
{
    int ret = 0;
    for(int i = 1; i <= n; ++i)
        ret += i;
    return ret;
}
```

> 1부터 n까지의 합을 계산하는 **재귀 함수**

```c
//필수조건 : n>=1
//결과 : 1부터 n까지의 합을 반환한다.
int recursiveSum(int n)
{
    if(n == 1) return 1; //더 이상 쪼개지지 않을 때(기저 사례)
    return n + recursiveSum(n-1);
}
```



### 예제 : 중첩 반복문 대체하기

0번부터 차례대로 번호 매겨진 n개의 원소 중 네 개를 고르는 모든 경우를 출력하는 코드를 작성한다.

ex) 입력 : n = 7 / 출력 :  (0, 1, 2, 3), (0, 1, 2, 4), (0, 1, 2, 5),  …, (3, 4, 5, 6)

> 4중 for문으로 작성하기

```c
for(int i = 0; i < n; i++)
    for(int j = i + 1; j < n; j++)
        for(int k = j + 1; k < n; k++)
            for(int l = k + 1; l < n; l++)
                cout << i << ", " << j << ", " << k << ", " << l << endl; 
```

위와 같은 중첩 for문은 골라야 할 원소의 수가 늘어날수록 코드가 길고 복잡해지며 골라야할 원소의 수가 입력에 따라 달라질 수 있는 경우에는 사용할 수가 없는 문제점이 있다. 재귀호출은 이런 경우에 단순 반복문보다 간결하고 유연한 코드를 작성할 수 있도록 해 준다.

위 작업을 네 개의 조각으로 나눌 수 있다. 각 조각에서 하나의 원소를 고르고 자기 자신을 호출해 남은 원소들을 고르는 작업한다.

남은 원소들을 고르는 작업을 다음과 같은 입력들의 집합으로 정의할 수 있다.

- 원소들의 총 개수

- 더 골라야 할 원소들의 개수

- 지금까지 고른 원소들의 번호


>  n개의 원소 중 m개를 고르는 모든 조합을 찾는 알고리즘

```c
//n : 전체 원소의 수
//picked : 지금까지 고른 원소들의 번호
//toPick : 더 고를 원소의 수
//앞으로 toPick개의 원소를 고르는 모든 방법 출력
void printPicked(vector<int>& p)
{
	for (int i = 0; i < p.size(); i++)
	{
		cout << p[i];
		(i == p.size() - 1) ? cout << endl : cout << ", ";
	}
}

void pick(int n, vector<int>& picked, int toPick)
{
    //기저 사례 : 더 고를 원소가 없을 때 고른 원소들을 출력한다.
    if(toPick == 0) { printPicked(picked); return; }
    //고를 수 있는 가장 작은 번호를 계산한다.
    int smallest = picked.empty() ? 0 : picked.back() + 1;
    //이 단계에서 원소 하나를 고른다.
    for(int next = smallest; next < n; next++)
    {
        picked.push_back(next);
        pick(n, picked, toPick - 1);
        picked.pop_back();
    }
}

int main()
{
    vector<int> picks;
    
    pick(6, picks, 4);
    
    return 0;
}
```

비어있는 답에서 시작해서 매 단계마다 하나의 원소를 추가하는 작업을 반복하여 하**나의 답을 만들어 출력한 뒤, 이전 단계로 돌아가 다른 원소를 추가**하는 식으로 모든 답을 생성한다.

재귀 호출을 이용하면 특정 조건을 만족하는 조합을 모두 생성하는 코드를 쉽게 작성할 수 있다. 때문에 재귀 호출은 완전 탐색을 구현할 때 유용하다.



### 예제 : 보글 게임(문제 ID : BOGGLE, 난이도 : 하) [문제 내용](https://algospot.com/judge/problem/read/BOGGLE )

hasWord(y, x, word) = 보글 게임판의 (y, x)에서 시작하는 단어 word의 존재 여부를 반환한다.

이 문제를 풀 때 까다로운 점은 다음 글자가 될 수 있는 칸이 여러 개 있을 때, 이 중 어느 글자를 선택해야 할지 미리 알 수 없다는 점이다. 이 문제점은 완전 탐색을 이용해, 단어를 찾아낼 때까지 모든 인접한 칸을 하나씩 시도해 보는 것이다.

#### 문제의 분할

hasWord(y, x, word)를 자연스럽게 조각내는 방법은 각 글자를 하나의 조각으로 만드는 것이다. 시작 위치를 정할 때, 시작 위치가 단어의 첫 글자와 일치하지 않는다면 false를 반환하여 함수를 종료한다. 시작 위치와 첫 글자가 일치한다면 다음 글자는 시작위치에 인접한 여덟 칸에서 찾아내며, 찾았다면 마찬가지로 다음 글자도 전 글자 칸에 인접한 여덟 칸에서 찾아내면 된다.

#### 기저 사례의 선택

1. 시작 위치가 범위 밖이면 항상 실패
2. 위치 (y, x)에 있는 글자가 원하는 단어의 첫 글자가 아닌 경우 항상 실패
3. (1번 경우에 해당되지 않을 경우) 원하는 단어가 한 글자인 경우 항상 성공

※ **2, 3번 조건은 순서가 바뀌어선 안된다.**

#### 구현

> 보글 게임판에서 단어를 찾는 재귀 호출 알고리즘

```c
const int dx[8] = {-1, -1, -1,  1, 1, 1,  0, 0};
const int dy[8] = {-1,  0,  1, -1, 0, 1, -1, 1};
//5X5의 보글 게임 판의 해당 위치에서 주어진 단어가 시작하는지를 반환
bool hasWord(int y, int x, const string& word)
{
    //기저 사례 1: 시작 위치가 범위 밖이면 실패
    if(!inRange(y, x)) return false;
    //기저 사례 2: 첫 글자가 일치하지 않으면 실패
    if(board[y][x] != word[0]) return false;
    //기저 사례 3: 단어 길이가 1이면 
	if(word.size() == 1) return true;
    //인접한 여덟 칸을 검사한다.
    for(int direction = 0; direction < 8; direction++)
    {
        int nextY = y + dy[direction], nextX = x + dx[direction];
        //다음 칸이 범위 안에 있는지, 첫 글자는 일치하는지 확인할 필요가 없다.
        if(hasWord(nextY, nextX, word.substr(1)))
            return true;
	}
    return false;
}
```

#### 시간 복잡도 분석

완전 탐색은 가능한 답 후보들을 모두 만들어 보기 때문에 가능한 후보의 최대 수를 계산하면 된다. 각 칸에는 최대 여덟 개의 이웃이 있고, 탐색은 단어의 길이 N에 대해 N-1 단계 진행 되므로, 이 알고리즘의 시간 복잡도는 최대 $$8^{N-1}=O(8^N)$$이다.

이 문제에서 **후보의 수는 단어의 길이에 따라 지수적으로 증가**하기 때문에 **단어의 길이가 짧은 경우에만 완전 탐색으로 해결**할 수 있다. 따라서 단어의 길이가 조금이라도 길어질 경우 다른 설계 패러다임(동적 계획법 등)들을 사용해야 한다.

#### 완전 탐색 레시피

1. 완전 탐색은 존재하는 모든 답을 하나씩 검사하므로, **걸리는 시간은 가능한 답의 수에 정확히 비례**한다. 최대 크기의 입력을 가정했을 때 답의 개수를 계산하고 이들을 모두 제한 시간 안에 생성할 수 있는지를 가늠한다.

2. 가능한 모든 답의 후보를 만드는 과정을 여러 개의 선택으로 나눈다. **각 선택은 답의 후보를 만드는 과정의 한 조각**이 된다.

3. 그 중 하나의 조각을 선택해 답의 일부를 만들고, **나머지 답을 재귀 호출을 통해 완성**한다.

4. **조각이 하나밖에 남지 않은 경우, 혹은 하나도 남지 않은 경우**에는 답을 생성했으므로, 이것을 **기저 사례로 선택해 처리**한다.

#### 이론적 배경 : 재귀호출과 부분 문제

보글 게임에서 문제는 '게임판에서의 현재 위치 (y, x) 그리고 단어 word가 주어질 때 해당 단어를 이 칸에서부터 시작해서 찾을 수 있는가?'로 정의 된다. 그리고 해당 단어를 이 위치에서 찾을 수 있는지 알기 위해 최대 아홉 가지 정보를 알아야 한다.

1. 현재 위치 (y,x)에 단어의 첫 글자가 있는가?
2. 윗 칸 (y-1, x)에서 시작해서, 단어의 나머지 글자들을 찾을 수 있는가?
3. 왼쪽 위 칸 (y-1, x-1)에서 시작해서 단어의 나머지 글자들을 찾을 수 있는가?
4. … (반복)

이 중 2번 이후의 항목은 원래 문제에서 한 조각 떼어냈을 뿐, 형식이 같은 또다른 문제를 푼 결과이다. 문제를 구성하는 조각들 중 하나를 뺐기 때문에, 이 문제들을 원래 문제의 일부라고 할 수 있다. 이 문제들을 원래 문제의 부분 문제라고 한다.



## 3. 문제 : 소풍 [(문제 내용)](https://algospot.com/judge/problem/read/PICNIC )

#### 완전 탐색

이 문제와 같이 가능한 조합의 수를 계산하는 문제는 완전 탐색을 이용해 조합을 모두 만들어 보는 것이 가장 간단하다. 그러므로 재귀 호출을 이용해 문제를 해결해본다.

재귀호출을 이용해 문제를 해결하려면 우선 각 답을 만드는 과정을 여러 개의 조각으로 나누어야 한다. 여기서는 전체 문제를 $\frac n 2$개의 조각으로 나눠서 한 조각마다 두 학생을 짝지어 주는 것으로 한다. 이때 문제의 형태는 '아직 짝을 찾지 못한 학생들의 명단이 주어질 때 친구끼리 둘씩 짝짓는 경우의 수를 계산하라'가 된다. 서로 친구인 두 학생을 찾아 이들을 짝지어 주고 나면 남은 학생들을 짝지어 주는 문제도 원래 문제와 같은 형태가 되기 때문이다.

#### 중복으로 세는 문제

> 소풍 문제를 해결하는 (잘못된) 재귀 호출 코드

```c
int n;
bool areFriends[10][10];
//taken[i] = i번째 학생이 짝을 이미 찾았으면 true, 아니면 false
int countPairings(bool taken[10])
{
    //기저 사례 : 모든 학생이 짝을 찾았으면 한 가지 방법을 찾았으니 종료한다.
    bool finished = true;
    for(int i = 0; i < n; i++)
    {
        if(!taken[i]) 
            finished = false;
	}
    if(finished)
        return true;
    int ret = 0;
    //서로 친구인 두 학생을 찾아 짝을 지어 준다.
    for(int i = 0; i < n; i++)
        for(int j = 0; j < n; j++)
            if(!taken[i] && !taken[j] && areFriends[i][j])
            {
                taken[i] = taken[j] = true;
                ret += countPairings(taken);
                taken[i] = taken[j] = false;
			}
    return ret;
}
```

#### 문제점

* 같은 학생 쌍을 두 번 짝지어 준다. 예를 들어 (0, 1)과 (1, 0)을 따로 세고 있다.
* 다른 순서로 학생들을 짝지어 주는 것을 서로 다른 경우로 세고 있다. 예를 들어 (0, 1) 후에 (2, 3)을 짝지어 주는 것과 (2, 3) 후에 (0, 1)을 짝지어주는 것은 완전히 같은 방법인데 다른 경우로 세고 있다.

같은 답을 중복으로 세는 상황은 경우의 수를 다룰 때 가장 흔하게 마주치게 된다. 이 상황을 해결하기 위해 선택할 수 있는 좋은 방법은 항상 특정 형태를 갖는 답만 세는 것이다. 흔히 사용하는 방법으로 사전순으로 가장 먼저 오는 답 하나만을 세는 것이 있다. (2, 3), (0, 1)이나 (1, 0), (2, 3)은 세지 않지만 (0, 1), (2, 3)은 세는 것이다. 이 속성을 강제하기 위해선 각 단계에서 남아 있는 학생들 중 가장 번호가 빠른 학생의 짝을 찾아 주면 된다.

> 소풍 문제를 해결하는 재귀 호출 코드

```c
int n;
bool areFriends[10][10];
//taken[i] = i번째 학생이 짝을 이미 찾았으면 true, 아니면 false
int countPairings(bool taken[10])
{
    //남은 학생들 중 가장 번호가 빠른 학생을 찾는다.
	int firstFree = -1;
	for (int i = 0; i < n; i++)
	{
		if (!taken[i])
		{
			firstFree = i;
			break;
		}
	}
    //기저 사례 : 모든 학생이 짝을 찾았으면 기저 방법을 찾았으니 종료한다.
	if (firstFree == -1)
		return 1;
	int ret = 0;
    //이 학생과 짝지을 학생을 결정한다.
	for (int pairWith = firstFree + 1; pairWith < n; pairWith++)
	{
		if (!taken[pairWith] && areFriends[firstFree][pairWith])
		{
			taken[firstFree] = taken[pairWith] = true;
			ret += countPairings(taken);
			taken[firstFree] = taken[pairWith] = false;
		}
	}
	return ret;
}
```

#### 답의 수의 상한

모든 답을 생성해 가며 답의 수를 세는 재귀 호출 알고리즘은 답의 수에 정비례하는 시간이 걸린다. 따라서 프로그램을 작성하기 전에 답의 수가 얼마나 될지 예측해 보고 시간이 얼마나 걸릴지 확인해야 한다. 이 문제에서 가장 많은 가질 수 있는 입력은 열 명의 학생 모두 서로 친구인 경우이므로, 9 * 7 * 5 * 3* 1 = 945가 된다.



## 4. 문제 : 게임판 덮기 [(문제 내용)]( https://algospot.com/judge/problem/read/BOARDCOVER  )

게임 판을 덮을 수 있는 모든 경우를 생성하는 완전 탐색을 이용해 해결할 수 있다. 게임 판에서 흰 칸의 수가 3의 배수가 아닐 경우에는 무조건 답이 없으니 이 부분을 따로 처리한다. 이 외의 경우에는 흰 칸의 수를 3으로 나눠서 내려 놓을 블록의 수 N을 얻은 뒤, 문제의 답을 생성하는 과정을 N조각으로 나눠 한 조각에서 한 블록을 내려놓도록 한다. 흰 칸을 채우는 과정의 반복은 재귀호출을 이용한다.

#### 중복으로 세는 문제

블록을 놓는 순서는 상관이 없으나 같은 배치도 블록을 놓는 순서에 따라 여러 번 세기 때문에 특정한 순서대로 셀 수 있도록 강제해야 한다. 가장 간편한 방법은 재귀 호출의 각 단게마다 빈 칸 중에서 가장 윗 줄, 가장 왼쪽에 있는 칸을 채우는 것이다. 이렇게 하면 한 답을 한 가지 방법으로밖에 생성할 수 없으므로 중복으로 세는 문제를 해결할 수 있다.

항상 빈 칸 중 가장 윗줄, 가장 왼쪽에 있는 칸을 처음 채운다고 가정하기 때문에 왼쪽과 위에 있는 칸은 항 상 이미 채워져 있다고 가정할 수 있다. 따라서 각 칸은 ┎,  ┓, ┗, ┛로 네 가지이다. 재귀 호출 알고리즘은 가장 윗줄, 가장 왼쪽 칸인 첫 번째 빈 칸을 찾은 후 덮을 방법을 네 가지 방법으로 시도한다. 이 방법이 달라질 때마다 서로 다른 배치가 되므로, 답은 남은 게임판을 재귀 호출에 넘겨서 얻은 경우의 수를 모두 더한 수가 된다.

#### 답의 수의 상한

흰 칸의 수는 50을 넘지 않으므로, $\frac {50} {3} = 16$개의 블록을 놓기 때문에 가능한 답의 상한은 $4^6=2^{32}$개가 된다. 하지만 실제 입력을 손으로 풀어보면 블록 배치가 크게 제한됨을 알 수 있다. 따라서 실제 답의 수는 이 상한보다 훨씬 작다.

#### 구현

> 게임판 덮기 문제를 해결하는 재귀 호출 알고리즘

```c
//주어진 칸을 덮을 수 있는 네 가지 방법
//블록을 구성하는 세 칸의 상대적 위치(dy, dx)의 목록(┎,  ┓, ┗, ┛)
const int coverType[4][3][2] =
{
    {{0, 0}, {1, 0}, {0, 1}}, //(┎)
    {{0, 0}, {0, 1}, {1, 1}}, //(┓)
    {{0, 0}, {1, 0}, {1, 1}}, //(┗)
    {{0, 0}, {1, 0}, {1,-1}}  //(┛)
};
//board의 (y, x)를 type번 방법으로 덮거나, 덮었던 블록을 없앤다.
//delta = 1이면 덮고, -1이면 덮었던 블록을 없앤다.
//만약 블록이 제대로 덮이지 않은 경우 (게임판 밖으로 나가거나, 겹치거나, 검은 칸을 덮을 때) false를 반환한다.
bool set(vector<vector<int>>& board, int y, int x, int type, int delta)
{
    bool ok = true;
    for(int i = 0; i < 3; i++)
    {
        const int ny = y + coverType[type][i][0];
        const int nx = x + coverType[type][i][1];
        if(ny < 0 || ny >= board.size() || nx < 0 || ny >= board[0].size())
            ok = false;
        else if((board[ny][nx] += delta) > 1)
            ok = false;
    }
    return ok;
}
//board의 모든 빈 칸을 덮을 수 있는 방법의 수를 반환한다.
//board[i][j] = 1 이미 덮인 칸 혹은 검은 칸
//board[i][j] = 0 아직 덮이지 않은 칸
int cover(vector<vector<int>>& board)
{
    //아직 채우지 못한 칸 중 가장 윗줄 왼쪽에 있는 칸을 찾는다.
    int y = -1, x = -1;
    for(int i = 0; i < board.size(); i++)
    {
        for(int j = 0; j < board[i].size(); j++)
        {
            if(board[i][j] == 0)
            {
                y = i;
                x = j;
                break;
            }
		}
        if(y != -1) break;
    }
    //기저 사례 : 모든 칸을 채웠으면 1을 반환한다.
    if(y == -1) return 1;
    int ret = 0;
    for(int type = 0; type < 4; type++)
    {
        //만약 board[y][x]를 type 형태로 덮을 수 있으면 재귀 호출한다.
        if(set(board, y, x, type, 1))
            ret += cover(board);
        //덮었던 블록을 치운다.
        set(board, y, x, type, -1);
    }
    return ret;
}
```

## 5. 최적화 문제

문제의 답이 될 수 있는 것이 하나가 아니라 여러 개이고, 그 중에서 어떤 **기준에 따라 가장 '좋은' 답을 찾아 내는 문제**들을 **최적화 문제(Optimization problem)**라고 부른다.

### 예제 : 여행하는 외판원 문제 [(문제 내용)]( https://algospot.com/judge/problem/read/TSP1 )

#### 무식하게 풀기

이 문제는 완전 탐색으로 문제를 해결할 수 있다. 완전 탐색으로 문제를 풀기 위한 첫 번째 단계는 시간 안에 답을 구할 수 있는지 확인하는 것이다. 시작한 도시로 돌아오는 경로를 찾기 때문에, 경로의 시작점은 신경 쓰지 않고 무조건 0번 도시에서 출발한다고 가정해도 경로의 길이가 다르지 않다. 따라서 남은 도시들을 어떤 순서로 방문할지만 정하면 된다. n-1개의 도시를 나열하는 방법은 (n-1)!가지이기 때문에 완전 탐색으로 충분히 문제를 해결할 수 있다.

#### 재귀 호출을 통한 답안 생성

이 문제의 모든 답은 재귀 호출을 이용해 간단하게 만들 수 있다. n개의 도시로 구성된 경로를 n개의 조각으로 나눠, 앞에서부터 도시를 하나씩 추가해 경로를 만들어 다음과 같은 형태의 함수를 작성해 해결할 수 있다.

shortesPath(path) = path가 지금까지 만든 경로일 때, 나머지 도시들을 모두 방문하는 경로들 중 가장 짧은 것의 길이를 반환한다.

> 여행하는 외판원 문제를 해결하는 재귀 호출 알고리즘

```c
int n;	//도시의 수
double dist[Max][Max];	//두 도시 간의 거리를 저장하는 배열
//path : 지금까지 만든 경로
//visited : 각 도시의 방문 여부
//currentLength : 지금까지 만든 경로의 길이
//나머지 도시들을 모두 방문하는 경로들 중 가장 짧은 것의 길이를 반환한다.
double shortestPath(vector<int>& path, vector<bool>& visited, double currentLength)
{
    //기저 사례 : 모든 도시를 다 방문했을 때는 시작 도시로 돌아가고 종료한다.
    if(path.size() == n)
        return currentLength + dist[path[0]][path.back()];
    double ret = INF;	//매우 큰 값으로 초기화
    //다음 방문할 도시를 전부 시도해 본다.
    for(int next = 0; next < n; next++)
    {
        if(visited[next]) continue;
        int here = path.back();
        path.push_back(next);
        visited[next] = true;
        //나머지 경로를 재귀 호출을 통해 완성하고 가장 짧은 경로의 길이를 얻는다.
        double cand = shortestPath(path, visited, curretnLength + dist[here][next]);
        ret = min(ret, cand);
        visited[next] = false;
        path.pop_back();
    }
    return ret;
}
```

위 코드의 특징은 각 정점을 방문했는지 나타내는 bool 값 배열 visited와 현재 경로의 길이 currentLength를 path와 함께 인자로 받고 있는 점이다. path를 이용해 이 visited와 current Length의 값을 쉽게 계산할 수 있기 때문에 이들은 필요가 없다. 이런 코드는 한 가지 정보는 한 가지 형태로만 저장한다는 프로그래밍 원칙에는 어긋나지만, 매번 각 정점을 방문했는지 확인하는 작업과 현재 경로의 길이를 구하는 작업을 더 효율적으로 수행할 수 있도록 해준다.

## 6. 문제 : 시계 맞추기 [(문제 내용)]( https://algospot.com/judge/problem/read/CLOCKSYNC )

#### 문제 변형하기

이 문제는 설명과 달리 스위치를 누르는 순서는 전혀 중요하지 않다. 누르는 순서를 바꾼다고 해서 결과가 바뀌지 않기 때문에 각 스위치를 몇 번 누를 것인지를 계산하는 것이 중요하다. 

시계는 12시간이 지나면 제 자리로 돌아오는 점을 이용하면 무한한 조합의 수를 유한하게 바꿀 수 있다. 한 스위치를 네 번 누르면 연결된 시계는 12시간씩 앞으로 이동하니 한 번도 누르지 않은 것과 같아지므로 각 스위치를 누르는 횟수는 0에서 3 사이에 정수가 된다. 따라서 열 개의 스위치가 있으니 전체 경우의 수는 $4^{10} = 1048576$개가 된다.  구현에 따라 다르지만 시간 안에 모든 경우를 세어 보기엔 무리 없는 크기이므로 완전 탐색을 통해 문제를 해결할 수 있다.

#### 완전 탐색 구현하기

문제를 모두 열 조각으로 나눈 후 조각에서 한 스위치를 누를 횟수를 정하는 식으로 재귀 호출 프로램을 구현한다. 재귀 호출의 깊이가 정해져 있기 때문에 10중 for문과 다르지 않지만, 이 쪽이 구현하기도 편하고 디버깅하기도 쉽다.

##### 유의점

* 만약 답을 구할 수 없을 경우 재귀 함수의 반환 값은 문제의 출력 값인 -1이 아니라 매우 큰 값이 된다. solve()는  재귀 호출하면서 가장 작은 출력 값을 찾게 되는데, -1 대신에 매우 큰 값을 반환하기로 약속하면 답이 없는 경우를 따로 확인하지 않아도 되기 때문이다. 마지막에 답을 출력할 때 답이 매우 크다면 -1을 대신 출력해 주면 된다.
* 어떤 스위치가 어떤 시계에 연결되어 있는지를 2차원 배열을 통해 저장했다. i번째 스위치가 j번째 시계에 연결되어 있는지를 보려면 linked\[i][j]를 보면된다.

> 시계 맞추기 문제를 해결하는 완전 탐색 알고리즘

```c
const int INF = 9999; SWITCHES = 10, CLOCKS = 16;
//linked[i][j] = 'x' : i번 스위치와 j번 시계가 연결되어 있다.
//linked[i][j] = '.' : i번 스위치와 j번 시계가 연걸되어 있지 않다.
const char linked[SWITCHES][CLOCKS + 1] =
{
    //0123456789012345
    "xxx.............",
    "...x...x.x.x....",
    "....x.....x...xx",
    "x...xxxx........",
    "......xxx.x.x...",
    "x.x...........xx",
    "...x..........xx",
    "....xx.x......xx",
    ".xxxxx..........",
    "...xxx...x...x.."
};
//모든 시계가 12시를 가리키고 있는지 확인한다.
bool areAligned(const vector<int>& clocks);
//switch번 스위치를 누른다.
void push(vector<int>& clocks, int swtch)
{
    for(int clock = 0; clock < CLOCKS; clock++)
    {
        if(linked[swich][clock] == 'x')
        {
            clocks[clock] += 3;
            if(clocks[clock] == 15)
                clocks[clock] = 3;
        }
    }
}
//clocks : 현재 시계들의 상태
//swtch : 이번에 누를 스위치의 번호가 주어질 때, 남은 스위치들을 눌러서 clocks를 12시로 맞출 수 있는 최소 횟수를 반환한다.
//만약 불가능하다면 INF 이상의 큰 수를 반환한다.
int solve(vector<int>& clocks, int swtch)
{
    if(swtch == SWITCHES)
        return areAligned(clocks) ? 0 : INF;
    //이 스위치를 0번 누르는 경우부터 세 번 누르는 경우까지를 모두 시도한다.
    int ret = INF;
    for(int cnt = 0; cnt < 4; cnt++)
    {
        ret = min(ret, cnt + solve(clocks, swtch + 1));
        push(clocks, swtch);
    }
    //push(clocks, swtch)가 네 번 호출되었으니 clocks는 원래와 같은 상태가 된다.
    return ret;
}
```

## 7. 많이 등장하는 완전 탐색 유형

입력의 크기에 따라 답의 개수가 어떻게 변하는지를 알고 구현한다.

#### 모든 순열 만들기

**서로 다른 N개의 원소를 일렬로 줄 세운 것을 순열(permutation)**이라고 한다.  주어진 원소의 모든 순열을 생성해서 풀 수 있는 문제는 빈번하고 다른 문제의 부분 문제로도 나타나므로 순열을 생성하는 코드를 신경써서 작성해본다. C++는 STL에 포함된 next_permutation() 함수를 통해 모든 순열을 순서대로 생성하는 작업을 할 수 있다.

#### 모든 조합 만들기

**서로 다른 N개의 원소 중에서 R개를 순서 없이 골라낸 것을 조합(combination)**이라고 한다. 이전에 작성했던 n개의 원소 중 m개를 고르는 모든 조합을 찾는 알고리즘을 예로 들 수 있다. 이 때의 경우의 수는 이항계수로 정의 된다.

#### $2^n$가지 경우의 수 만들기

**n개의 질문에 대한 답이 예/아니오 중의 하나라고 할 때 존재할 수 있는 답의 모든 조합의 수는 $2^n$가지**이다. 이 모든 조합들을 생성하는 것은 굉장히 흔한 문제이다. n비트 정수로 표현한다고 생각하면 재귀 호출을 사용할 것 없이 1차원 for문 하나로 이 조합들을 간단하게 모두 시도할 수 있다.
